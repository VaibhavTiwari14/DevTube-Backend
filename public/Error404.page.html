<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DevTube - 404 Page Not Found</title>
    <meta name="description" content="The page you're looking for doesn't exist on DevTube. Return to our homepage to explore our best content.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800&family=Source+Sans+Pro:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary: #0070f3;
        --accent: #7c3aed;
        --danger: #e11d48;
        --success: #10b981;
        --white: #ffffff;
        --black: #000000;
        --gray-50: #f9fafb;
        --gray-100: #f3f4f6;
        --gray-900: #111827;
        --gray-800: #1f2937;
        --gray-700: #374151;
        --border-radius: 12px;
        --border-radius-sm: 8px;
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        --font-display: 'Montserrat', sans-serif;
        --font-body: 'Source Sans Pro', sans-serif;
        --font-mono: 'JetBrains Mono', monospace;
      }
      
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      html, body {
        height: 100%;
        overflow: hidden;
      }
      
      body {
        background: #000000;
        color: var(--white);
        font-family: var(--font-body);
        display: flex;
        flex-direction: column;
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        position: relative;
      }
      
      /* Animated background particles */
      .bg-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        opacity: 0.1;
      }
      
      /* Navbar */
      .navbar {
        width: 100%;
        height: 80px;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 2rem;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1000;
        animation: slideDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      
      @keyframes slideDown {
        from {
          transform: translateY(-100%);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      .navbar-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }
      
      .logo {
        width: 48px;
        height: 48px;
        border-radius: 12px;
        background: linear-gradient(135deg, var(--primary), var(--accent));
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--white);
        position: relative;
        overflow: hidden;
        transition: var(--transition);
      }
      
      .logo::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        transform: rotate(45deg);
        transition: var(--transition);
        opacity: 0;
      }
      
      .logo:hover::before {
        animation: shimmer 0.8s ease-in-out;
      }
      
      @keyframes shimmer {
        0% { transform: translateX(-100%) rotate(45deg); opacity: 0; }
        50% { opacity: 1; }
        100% { transform: translateX(100%) rotate(45deg); opacity: 0; }
      }
      
      .devtube-title {
        font-size: 1.5rem;
        font-weight: 600;
        font-family: var(--font-display);
        background: linear-gradient(135deg, var(--white), #94a3b8);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -0.025em;
      }
      
      .capsule-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 24px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 9999px;
        color: var(--white);
        text-decoration: none;
        font-weight: 500;
        font-size: 0.875rem;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }
      
      .capsule-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s ease;
      }
      
      .capsule-btn:hover::before {
        left: 100%;
      }
      
      .capsule-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }
      
      .arrow {
        transition: transform 0.3s ease;
      }
      
      .capsule-btn:hover .arrow {
        transform: translateX(4px);
      }
      
      /* Main content */
      .main-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding-top: 80px;
        position: relative;
        z-index: 10;
      }
      
      .container {
        text-align: center;
        max-width: 1200px;
        padding: 2rem;
        animation: fadeInUp 1s cubic-bezier(0.16, 1, 0.3, 1) 0.3s both;
      }
      
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(60px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .error-title {
        font-size: clamp(1.5rem, 4vw, 2.5rem);
        font-weight: 300;
        font-family: var(--font-display);
        margin-bottom: 3rem;
        letter-spacing: -0.025em;
        line-height: 1.2;
        background: linear-gradient(135deg, var(--white), #94a3b8, var(--white));
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: textShine 3s ease-in-out infinite;
      }
      
      @keyframes textShine {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
      }
      
      /* Three.js container */
      .glitch-container {
        width: 100%;
        height: 400px;
        margin: 3rem 0;
        position: relative;
        border-radius: var(--border-radius);
        overflow: hidden;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 
          0 10px 30px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
      
      .error-desc {
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        font-weight: 300;
        color: #94a3b8;
        margin-bottom: 3rem;
        line-height: 1.6;
      }
      
      .home-btn {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        padding: 18px 36px;
        background: linear-gradient(135deg, #1e293b 0%, #475569 50%, #64748b 100%);
        color: var(--white);
        text-decoration: none;
        border-radius: 50px;
        font-family: var(--font-display);
        font-weight: 600;
        font-size: 1.1rem;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        overflow: hidden;
        box-shadow: 
          0 8px 32px rgba(30, 41, 59, 0.4),
          0 4px 16px rgba(71, 85, 105, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        animation: btnGlow 3s ease-in-out infinite alternate;
      }
      
      .home-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg, 
          transparent, 
          rgba(255, 255, 255, 0.4), 
          transparent
        );
        transition: left 0.8s cubic-bezier(0.19, 1, 0.22, 1);
        z-index: 1;
      }
      
      .home-btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1);
        z-index: 0;
      }
      
      .home-btn:hover::before {
        left: 100%;
      }
      
      .home-btn:hover::after {
        width: 300px;
        height: 300px;
      }
      
      .home-btn:hover {
        transform: translateY(-4px) scale(1.05);
        box-shadow: 
          0 12px 40px rgba(30, 41, 59, 0.6),
          0 8px 25px rgba(71, 85, 105, 0.4),
          0 2px 8px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
        filter: brightness(1.1) saturate(1.2);
      }
      
      .home-btn:active {
        transform: translateY(-2px) scale(1.02);
        transition: all 0.1s ease;
      }
      
      .home-btn svg {
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        z-index: 2;
        position: relative;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      }
      
      .home-btn:hover svg {
        transform: translateX(4px) rotate(15deg) scale(1.1);
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      }
      
      .home-btn span {
        z-index: 2;
        position: relative;
      }
      
      @keyframes btnGlow {
        0% {
          box-shadow: 
            0 8px 32px rgba(30, 41, 59, 0.4),
            0 4px 16px rgba(71, 85, 105, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        100% {
          box-shadow: 
            0 8px 32px rgba(30, 41, 59, 0.6),
            0 4px 16px rgba(71, 85, 105, 0.5),
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
      }
      
      /* Responsive design */
      @media (max-width: 1024px) {
        .container {
          max-width: 90%;
          padding: 1.5rem;
        }
        
        .glitch-container {
          height: 350px;
          margin: 2.5rem 0;
        }
        
        .error-title {
          font-size: clamp(1.25rem, 5vw, 2rem);
          margin-bottom: 2rem;
        }
        
        .error-desc {
          font-size: clamp(0.9rem, 3vw, 1.1rem);
          margin-bottom: 2.5rem;
        }
      }
      
      @media (max-width: 768px) {
        .navbar {
          padding: 0 1rem;
          height: 70px;
        }
        
        .navbar-left {
          gap: 12px;
        }
        
        .logo {
          width: 40px;
          height: 40px;
          font-size: 1.25rem;
        }
        
        .devtube-title {
          font-size: 1.25rem;
        }
        
        .main-content {
          padding-top: 70px;
        }
        
        .container {
          padding: 1rem;
          max-width: 95%;
        }
        
        .error-title {
          font-size: clamp(1.1rem, 6vw, 1.8rem);
          margin-bottom: 1.5rem;
          line-height: 1.3;
        }
        
        .glitch-container {
          height: 280px;
          margin: 2rem 0;
          border-radius: 8px;
        }
        
        .error-desc {
          font-size: clamp(0.85rem, 3.5vw, 1rem);
          margin-bottom: 2rem;
          line-height: 1.5;
        }
        
        .home-btn {
          padding: 14px 28px;
          font-size: 0.95rem;
          gap: 10px;
          letter-spacing: 0.25px;
        }
        
        .home-btn svg {
          width: 18px;
          height: 18px;
        }
        
        .capsule-btn {
          padding: 10px 18px;
          font-size: 0.8rem;
          gap: 6px;
        }
        
        .capsule-btn .arrow svg {
          width: 14px;
          height: 14px;
        }
        
        .bg-particles {
          opacity: 0.05;
        }
      }
      
      @media (max-width: 480px) {
        .navbar {
          padding: 0 0.75rem;
          height: 60px;
        }
        
        .navbar-left {
          gap: 8px;
        }
        
        .logo {
          width: 36px;
          height: 36px;
          font-size: 1.1rem;
          border-radius: 8px;
        }
        
        .devtube-title {
          font-size: 1.1rem;
        }
        
        .main-content {
          padding-top: 60px;
        }
        
        .container {
          padding: 0.75rem;
          max-width: 100%;
        }
        
        .error-title {
          font-size: clamp(1rem, 7vw, 1.5rem);
          margin-bottom: 1.25rem;
          line-height: 1.2;
        }
        
        .glitch-container {
          height: 220px;
          margin: 1.5rem 0;
          border-radius: 6px;
        }
        
        .error-desc {
          font-size: clamp(0.8rem, 4vw, 0.9rem);
          margin-bottom: 1.5rem;
          line-height: 1.4;
        }
        
        .home-btn {
          padding: 12px 24px;
          font-size: 0.85rem;
          gap: 8px;
          letter-spacing: 0.1px;
          border-radius: 40px;
        }
        
        .home-btn svg {
          width: 16px;
          height: 16px;
        }
        
        .capsule-btn {
          padding: 8px 16px;
          font-size: 0.75rem;
          gap: 4px;
        }
        
        .capsule-btn .arrow svg {
          width: 12px;
          height: 12px;
        }
        
        .bg-particles {
          opacity: 0.03;
        }
        
        /* Optimize animations for mobile */
        .home-btn:hover {
          transform: translateY(-2px) scale(1.02);
        }
        
        .capsule-btn:hover {
          transform: translateY(-1px);
        }
      }
      
      @media (max-width: 360px) {
        .navbar {
          padding: 0 0.5rem;
        }
        
        .container {
          padding: 0.5rem;
        }
        
        .error-title {
          font-size: clamp(0.9rem, 8vw, 1.3rem);
          margin-bottom: 1rem;
        }
        
        .glitch-container {
          height: 180px;
          margin: 1rem 0;
        }
        
        .error-desc {
          font-size: clamp(0.75rem, 4.5vw, 0.85rem);
          margin-bottom: 1.25rem;
        }
        
        .home-btn {
          padding: 10px 20px;
          font-size: 0.8rem;
        }
        
        .devtube-title {
          font-size: 1rem;
        }
      }
      
      /* Landscape mobile optimization */
      @media (max-height: 600px) and (orientation: landscape) {
        .container {
          padding: 1rem;
        }
        
        .error-title {
          margin-bottom: 1rem;
          font-size: clamp(1rem, 4vw, 1.5rem);
        }
        
        .glitch-container {
          height: 200px;
          margin: 1.5rem 0;
        }
        
        .error-desc {
          margin-bottom: 1.5rem;
        }
        
        .navbar {
          height: 60px;
        }
        
        .main-content {
          padding-top: 60px;
        }
      }
      
      /* High DPI displays */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        .logo::before {
          transform: scale(0.5);
        }
        
        .home-btn::before {
          background: linear-gradient(
            90deg, 
            transparent, 
            rgba(255, 255, 255, 0.3), 
            transparent
          );
        }
      }
      
      /* Reduced motion for accessibility */
      @media (prefers-reduced-motion: reduce) {
        .error-title {
          animation: none;
        }
        
        .home-btn {
          animation: none;
        }
        
        .logo::before {
          animation: none;
        }
        
        .capsule-btn::before,
        .home-btn::before,
        .home-btn::after {
          transition: none;
        }
        
        .bg-particles {
          display: none;
        }
      }
      
      /* Loading animation */
      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top: 3px solid var(--white);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <!-- Background particles canvas -->
    <canvas class="bg-particles" id="particles"></canvas>
    
    <div class="navbar">
      <div class="navbar-left">
        <span class="devtube-title">DevTube</span>
      </div>
      <div class="navbar-right">
        <a href="/" class="capsule-btn" aria-label="Return to homepage">
          Return to home
          <span class="arrow">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
              <path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
        </a>
      </div>
    </div>
    
    <main class="main-content">
      <div class="container">
        <h1 class="error-title">
          This page seems to have glitched out of existence
        </h1>
        
        <div class="glitch-container" id="glitch-container">
          <div class="loading" id="loading"></div>
        </div>
        
        <p class="error-desc">
          Don't worry, even the best systems have their quirks. Let's get you back on track to discover amazing content.
        </p>
        
        <a href="/" class="home-btn">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
            <path d="M10 2L3 7V18H7V13H13V18H17V7L10 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>Back to Homepage</span>
        </a>
      </div>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Particle background
      function initParticles() {
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');
        
        // Initialize particles array first
        const particles = [];
        const particleCount = 100;
        
        // Responsive particle background with performance optimization
        function resize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          
          // Adjust particle count based on screen size and performance
          const isMobile = window.innerWidth <= 768;
          const isSmallMobile = window.innerWidth <= 480;
          
          // Clear existing particles and recreate with appropriate count
          particles.length = 0;
          
          let targetCount = particleCount;
          if (isSmallMobile) {
            targetCount = 30;
          } else if (isMobile) {
            targetCount = 50;
          }
          
          // Create particles
          for (let i = 0; i < targetCount; i++) {
            particles.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 0.5,
              vy: (Math.random() - 0.5) * 0.5,
              size: Math.random() * 2 + 1,
              opacity: Math.random() * 0.5 + 0.1
            });
          }
        }
        
        resize();
        window.addEventListener('resize', resize);
        
        // Performance-optimized animation loop
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        function animate(currentTime) {
          requestAnimationFrame(animate);
          
          // Throttle frame rate on mobile devices
          if (currentTime - lastFrameTime < frameInterval) {
            return;
          }
          lastFrameTime = currentTime;
          
          const isMobile = window.innerWidth <= 768;
          
          // Reduce particle animation complexity on mobile
          if (!isMobile || Math.random() > 0.3) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
              particle.x += particle.vx;
              particle.y += particle.vy;
              
              if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
              if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;
              
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
              ctx.fill();
            });
          }
        }
        
        animate();
      }
      
      // Advanced Three.js glitch effect
      function initGlitchEffect() {
        const container = document.getElementById('glitch-container');
        const loading = document.getElementById('loading');
        const width = container.offsetWidth;
        const height = container.offsetHeight;
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true,
          powerPreference: "high-performance"
        });
        
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);
        
        // Hide loading
        loading.style.display = 'none';
        
        // Create text geometry
        const loader = new THREE.FontLoader();
        
        // Fallback to canvas-based text if font loading fails
        createCanvasText();
        
        function createCanvasText() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 1024;
          canvas.height = 512;
          
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.font = 'bold 180px Montserrat, sans-serif';
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('404', canvas.width / 2, canvas.height / 2);
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = true;
          
          // Advanced shader material with multiple effects
          const material = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0 },
              tDiffuse: { value: texture },
              glitchIntensity: { value: 0.1 },
              distortion: { value: 0.05 },
              colorShift: { value: 0.03 },
              scanlines: { value: 0.8 },
              noise: { value: 0.2 },
              resolution: { value: new THREE.Vector2(width, height) }
            },
            vertexShader: `
              varying vec2 vUv;
              uniform float time;
              uniform float distortion;
              
              void main() {
                vUv = uv;
                vec3 pos = position;
                
                // Vertex displacement for wave effect
                pos.z += sin(pos.x * 0.1 + time * 2.0) * distortion * 10.0;
                pos.y += cos(pos.x * 0.1 + time * 1.5) * distortion * 5.0;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform sampler2D tDiffuse;
              uniform float glitchIntensity;
              uniform float colorShift;
              uniform float scanlines;
              uniform float noise;
              uniform vec2 resolution;
              varying vec2 vUv;
              
              // Random function
              float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
              }
              
              // Noise function
              float noise2D(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(mix(random(i + vec2(0.0, 0.0)), random(i + vec2(1.0, 0.0)), u.x),
                          mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y);
              }
              
              void main() {
                vec2 uv = vUv;
                float t = time * 0.5;
                
                // Digital glitch effect
                float glitch = step(0.9, random(vec2(floor(uv.y * 100.0), floor(t * 10.0))));
                float glitchOffset = (random(vec2(floor(uv.y * 20.0), floor(t * 5.0))) - 0.5) * glitchIntensity;
                
                // RGB shift
                vec2 uvR = uv + vec2(glitchOffset + colorShift, 0.0);
                vec2 uvG = uv + vec2(glitchOffset, 0.0);
                vec2 uvB = uv + vec2(glitchOffset - colorShift, 0.0);
                
                float r = texture2D(tDiffuse, uvR).r;
                float g = texture2D(tDiffuse, uvG).g;
                float b = texture2D(tDiffuse, uvB).b;
                
                // Scanlines
                float scanline = sin(uv.y * resolution.y * 0.5) * 0.5 + 0.5;
                scanline = mix(1.0, scanline, scanlines);
                
                // TV noise
                float noiseValue = noise2D(uv * 200.0 + t * 100.0) * noise;
                
                // Block glitch
                float blockGlitch = step(0.95, random(vec2(floor(uv.x * 50.0), floor(uv.y * 50.0) + floor(t * 20.0))));
                vec2 blockOffset = vec2(
                  (random(vec2(floor(uv.y * 10.0), floor(t * 30.0))) - 0.5) * blockGlitch * 0.1,
                  0.0
                );
                
                if (blockGlitch > 0.0) {
                  r = texture2D(tDiffuse, uv + blockOffset).r;
                  g = texture2D(tDiffuse, uv + blockOffset).g;
                  b = texture2D(tDiffuse, uv + blockOffset).b;
                }
                
                vec3 color = vec3(r, g, b);
                
                // Apply effects
                color *= scanline;
                color += noiseValue;
                
                // Vignette
                float vignette = 1.0 - length(uv - 0.5) * 0.8;
                color *= vignette;
                
                // Enhance contrast
                color = pow(color, vec3(1.2));
                
                gl_FragColor = vec4(color, 1.0);
              }
            `,
            transparent: true,
            side: THREE.DoubleSide
          });
          
          // Create geometry
          const geometry = new THREE.PlaneGeometry(8, 4, 32, 16);
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);
          
          // Position camera
          camera.position.z = 5;
          
          // Lighting
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          scene.add(ambientLight);
          
          const pointLight = new THREE.PointLight(0x7c3aed, 1, 100);
          pointLight.position.set(0, 0, 10);
          scene.add(pointLight);
          
          // Particle system
          const particleGeometry = new THREE.BufferGeometry();
          const particleCount = 1000;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          const sizes = new Float32Array(particleCount);
          
          for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
            
            colors[i * 3] = Math.random();
            colors[i * 3 + 1] = Math.random();
            colors[i * 3 + 2] = Math.random();
            
            sizes[i] = Math.random() * 5 + 1;
          }
          
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
          
          const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0 }
            },
            vertexShader: `
              attribute float size;
              attribute vec3 color;
              varying vec3 vColor;
              uniform float time;
              
              void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + sin(time + position.x * 0.1) * 0.3);
                gl_Position = projectionMatrix * mvPosition;
              }
            `,
            fragmentShader: `
              varying vec3 vColor;
              
              void main() {
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;
                
                float alpha = 1.0 - smoothstep(0.3, 0.5, r);
                gl_FragColor = vec4(vColor, alpha * 0.3);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
          });
          
          const particles = new THREE.Points(particleGeometry, particleMaterial);
          scene.add(particles);
          
          // Animation loop
          function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = performance.now() * 0.001;
            
            // Update shader uniforms
            material.uniforms.time.value = elapsedTime;
            material.uniforms.glitchIntensity.value = 0.1 + Math.sin(elapsedTime * 2) * 0.05;
            material.uniforms.distortion.value = 0.02 + Math.sin(elapsedTime) * 0.02;
            
            particleMaterial.uniforms.time.value = elapsedTime;
            
            // Rotate mesh slightly
            mesh.rotation.x = Math.sin(elapsedTime * 0.3) * 0.1;
            mesh.rotation.y = Math.cos(elapsedTime * 0.2) * 0.1;
            
            // Animate particles
            particles.rotation.y = elapsedTime * 0.1;
            
            // Camera movement
            camera.position.x = Math.sin(elapsedTime * 0.5) * 0.5;
            camera.position.y = Math.cos(elapsedTime * 0.3) * 0.3;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
          }
          
          animate();
        }
        
        // Handle resize with debouncing
        let resizeTimeout;
        function handleResize() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            const newWidth = container.offsetWidth;
            const newHeight = container.offsetHeight;
            
            // Update camera
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            
            // Update renderer
            renderer.setSize(newWidth, newHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Update canvas dimensions
            canvas.width = newWidth * 2;
            canvas.height = newHeight * 2;
            
            // Responsive font size for canvas text
            const fontSize = Math.min(newWidth * 0.25, newHeight * 0.4, 180);
            ctx.font = `bold ${fontSize}px Montserrat, sans-serif`;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('404', canvas.width / 2, canvas.height / 2);
            
            // Update texture
            texture.needsUpdate = true;
            
            // Update geometry for smaller screens
            const scale = Math.min(newWidth / 500, newHeight / 250, 1);
            mesh.scale.set(scale, scale, 1);
            
            // Update shader uniforms
            if (material.uniforms.resolution) {
              material.uniforms.resolution.value.set(newWidth, newHeight);
            }
          }, 100);
        }
        
        window.addEventListener('resize', handleResize);
      }
      
      
      // Initialize everything
      document.addEventListener('DOMContentLoaded', () => {
        initParticles();
        
        // Small delay to ensure container dimensions are available
        setTimeout(() => {
          if (typeof THREE !== 'undefined') {
            initGlitchEffect();
          } else {
            console.warn('Three.js not loaded, showing fallback');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('glitch-container').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; font-size: 4rem; font-weight: bold; font-family: var(--font-mono);">404</div>';
          }
        }, 100);
      });
    </script>
  </body>
</html>